"""
Plan Manager - Proaktivn√≠ pl√°nov√°n√≠ mise.

Tento modul transformuje reaktivn√≠ loop na proaktivn√≠ exekuci pl√°nu.
Vytv√°≈ô√≠ strukturovan√Ω pl√°n pomoc√≠ LLM, sleduje z√°vislosti a pokrok.

ARCHITEKTURA:
- PlanStep: Atomick√Ω krok s ID, popisem, z√°vislostmi, statusem
- PlanManager: Vytv√°≈ôen√≠ pl√°nu p≈ôes LLM, tracking pokroku, dependency resolution

KL√çƒåOV√â VLASTNOSTI:
- Z√°vislosti mezi kroky (step 3 nem≈Ø≈æe zaƒç√≠t p≈ôed dokonƒçen√≠m step 1, 2)
- Progress tracking (kolik % dokonƒçeno)
- Token estimation (kolik token≈Ø pravdƒõpodobnƒõ spot≈ôebuje ka≈æd√Ω krok)
- Serializace/deserializace pro persistence

POU≈ΩIT√ç:
    pm = PlanManager(llm_manager, project_root=".")
    
    # Vytvo≈ô pl√°n
    plan = await pm.create_plan("Refactoruj orchestrator.py")
    
    # Iteruj kroky
    while not pm.is_plan_complete():
        step = pm.get_next_step()  # Respektuje z√°vislosti
        if step:
            pm.mark_step_in_progress(step.id)
            # ... proveƒè krok ...
            pm.mark_step_completed(step.id, result, tokens_used)

THREAD SAFETY: Nen√≠ thread-safe!
"""

from typing import List, Dict, Any, Optional
from dataclasses import dataclass, field, asdict
from datetime import datetime
from core.rich_printer import RichPrinter
import json
import re


@dataclass
class PlanStep:
    """
    Reprezentuje jeden atomick√Ω krok v pl√°nu.
    
    Attributes:
        id: Unik√°tn√≠ ID kroku (1-indexed)
        description: Lidsky ƒçiteln√Ω popis co m√° b√Ωt udƒõl√°no
        status: Aktu√°ln√≠ stav ("pending", "in_progress", "completed", "failed", "skipped")
        dependencies: List ID krok≈Ø, kter√© mus√≠ b√Ωt dokonƒçeny p≈ôed t√≠mto krokem
        estimated_tokens: Odhad token≈Ø pro tento krok (0 = nezn√°m√©)
        actual_tokens: Skuteƒçnƒõ spot≈ôebovan√© tokeny (0 = je≈°tƒõ neprobƒõhlo)
        result: V√Ωsledek proveden√≠ (None pokud je≈°tƒõ neprobƒõhlo)
        error: Chybov√° hl√°≈°ka (None pokud √∫spƒõch nebo je≈°tƒõ neprobƒõhlo)
    """
    id: int
    description: str
    status: str = "pending"
    dependencies: List[int] = field(default_factory=list)
    estimated_tokens: int = 0
    actual_tokens: int = 0
    result: Optional[str] = None
    error: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Konverze na dictionary pro serializaci."""
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'PlanStep':
        """Vytvo≈ô√≠ PlanStep z dictionary."""
        return cls(**data)


class PlanManager:
    """
    Spravuje pl√°n mise - vytv√°≈ôen√≠, sledov√°n√≠, aktualizace.
    
    ARCHITEKTONICK√â ROZHODNUT√ç:
    - Pl√°n je vytvo≈ôen JEDNOU na zaƒç√°tku mise (m≈Ø≈æe b√Ωt replanov√°n p≈ôi selh√°n√≠)
    - Kroky jsou prov√°dƒõny v po≈ôad√≠ respektuj√≠c√≠m z√°vislosti
    - Progress je sledov√°n v re√°ln√©m ƒçase
    """
    
    def __init__(self, llm_manager, project_root: str = "."):
        """
        Inicializace PlanManager.
        
        Args:
            llm_manager: Instance LLMManager pro komunikaci s LLM
            project_root: Ko≈ôenov√Ω adres√°≈ô projektu
        """
        self.llm_manager = llm_manager
        self.project_root = project_root
        self.steps: List[PlanStep] = []
        self.current_step_index = 0
        self.plan_created_at: Optional[str] = None
    
    async def create_plan(
        self, 
        mission_goal: str, 
        context: str = "",
        max_steps: int = 10
    ) -> List[PlanStep]:
        """
        Vytvo≈ô√≠ pl√°n pro dan√Ω c√≠l mise pomoc√≠ LLM.
        
        Args:
            mission_goal: C√≠l mise (nap≈ô. "Refactoruj orchestrator.py")
            context: Dodateƒçn√Ω kontext (voliteln√Ω)
            max_steps: Maxim√°ln√≠ poƒçet krok≈Ø v pl√°nu
        
        Returns:
            Seznam PlanStep objekt≈Ø
        
        Raises:
            ValueError: Pokud LLM nevygeneruje validn√≠ pl√°n
        """
        RichPrinter.info("üìã Vytv√°≈ô√≠m pl√°n mise...")
        
        # Prompt pro LLM
        planning_prompt = self._build_planning_prompt(
            mission_goal, context, max_steps
        )
        
        # Zavolej LLM (pou≈æij "powerful" model pro strategick√© my≈°len√≠)
        try:
            model = self.llm_manager.get_llm("powerful")
        except (ValueError, FileNotFoundError):
            # Fallback na default model pokud "powerful" nen√≠ k dispozici
            RichPrinter.warning("‚ö†Ô∏è  'powerful' model nedostupn√Ω, pou≈æ√≠v√°m default")
            model = self.llm_manager.get_llm(self.llm_manager.default_llm_name)
        
        response, usage = await model.generate_content_async(planning_prompt)
        
        # Parse JSON z odpovƒõdi
        plan_data = self._parse_plan_from_response(response)
        
        if not plan_data or "steps" not in plan_data:
            raise ValueError("LLM nevygeneroval validn√≠ pl√°n")
        
        # Konverze na PlanStep objekty
        self.steps = [
            PlanStep(
                id=step["id"],
                description=step["description"],
                dependencies=step.get("dependencies", []),
                estimated_tokens=step.get("estimated_tokens", 500)
            )
            for step in plan_data["steps"][:max_steps]  # Limit krok≈Ø
        ]
        
        self.plan_created_at = datetime.now().isoformat()
        
        # Validace pl√°nu
        self._validate_plan()
        
        # Zobraz pl√°n
        self._display_plan()
        
        return self.steps
    
    def _build_planning_prompt(
        self, 
        mission_goal: str, 
        context: str,
        max_steps: int
    ) -> str:
        """Sestav√≠ prompt pro LLM."""
        return f"""Jsi strategick√Ω pl√°novaƒç pro AI agenta. Rozlo≈æ n√°sleduj√≠c√≠ √∫kol na konkr√©tn√≠, provediteln√© kroky.

√öKOL:
{mission_goal}

KONTEXT:
{context if context else "≈Ω√°dn√Ω dodateƒçn√Ω kontext."}

PO≈ΩADAVKY NA PL√ÅN:
1. Ka≈æd√Ω krok mus√≠ b√Ωt ATOMICK√ù (jedna jasn√° akce)
2. Ka≈æd√Ω krok mus√≠ b√Ωt TESTOVATELN√ù (lze ovƒõ≈ôit √∫spƒõch/selh√°n√≠)
3. Kroky mus√≠ b√Ωt se≈ôazeny LOGICKY (respektuj z√°vislosti)
4. Odhadni SLO≈ΩITOST ka≈æd√©ho kroku (tokens: 100-2000)
5. Maxim√°lnƒõ {max_steps} krok≈Ø
6. Pokud krok z√°vis√≠ na jin√©m kroku, uveƒè to v dependencies

P≈ò√çKLAD DOBR√âHO PL√ÅNU:
{{
  "steps": [
    {{
      "id": 1,
      "description": "P≈ôeƒçti soubor orchestrator.py a analyzuj jeho strukturu",
      "dependencies": [],
      "estimated_tokens": 300
    }},
    {{
      "id": 2,
      "description": "Identifikuj duplicitn√≠ k√≥d a navrhni refaktoring",
      "dependencies": [1],
      "estimated_tokens": 800
    }},
    {{
      "id": 3,
      "description": "Implementuj refactored_orchestrator.py s ƒçist≈°√≠m k√≥dem",
      "dependencies": [2],
      "estimated_tokens": 1200
    }},
    {{
      "id": 4,
      "description": "Spus≈• testy a ovƒõ≈ô ≈æe refaktoring nic nerozbil",
      "dependencies": [3],
      "estimated_tokens": 400
    }}
  ]
}}

FORM√ÅT ODPOVƒöDI (POUZE JSON, ≈æ√°dn√Ω markdown):
{{
  "steps": [
    {{
      "id": 1,
      "description": "...",
      "dependencies": [],
      "estimated_tokens": 500
    }},
    ...
  ]
}}
"""
    
    def _parse_plan_from_response(self, response: str) -> Optional[Dict[str, Any]]:
        """
        Parse JSON pl√°nu z LLM odpovƒõdi.
        
        Um√≠ zpracovat:
        - ƒåist√Ω JSON
        - JSON v markdown code blocku
        - JSON s extra textem p≈ôed/po
        """
        # Pokus 1: Najdi JSON v markdown code blocku
        json_match = re.search(r'```(?:json)?\s*\n(.*?)\n```', response, re.DOTALL)
        if json_match:
            json_str = json_match.group(1).strip()
            try:
                return json.loads(json_str)
            except json.JSONDecodeError as e:
                RichPrinter.warning(f"‚ö†Ô∏è  JSON v code blocku nen√≠ validn√≠: {e}")
        
        # Pokus 2: Najdi prvn√≠ validn√≠ JSON objekt
        brace_start = response.find('{')
        if brace_start != -1:
            # Najdi matching uzav√≠rac√≠ z√°vorku
            brace_count = 0
            for i in range(brace_start, len(response)):
                if response[i] == '{':
                    brace_count += 1
                elif response[i] == '}':
                    brace_count -= 1
                    if brace_count == 0:
                        json_str = response[brace_start:i+1]
                        try:
                            return json.loads(json_str)
                        except json.JSONDecodeError as e:
                            RichPrinter.warning(f"‚ö†Ô∏è  Extrahovan√Ω JSON nen√≠ validn√≠: {e}")
                        break
        
        # Pokus 3: Zkus parsovat celou odpovƒõƒè jako JSON
        try:
            return json.loads(response.strip())
        except json.JSONDecodeError:
            RichPrinter.error("‚ùå Nepoda≈ôilo se zparsovat pl√°n z LLM odpovƒõdi")
            RichPrinter.error(f"Odpovƒõƒè LLM:\n{response[:500]}...")
            return None
    
    def _validate_plan(self):
        """
        Validuje pl√°n na konzistenci.
        
        Raises:
            ValueError: Pokud pl√°n nen√≠ validn√≠
        """
        if not self.steps:
            raise ValueError("Pl√°n je pr√°zdn√Ω")
        
        # Kontrola unik√°tn√≠ch ID
        step_ids = [s.id for s in self.steps]
        if len(step_ids) != len(set(step_ids)):
            raise ValueError("Pl√°n obsahuje duplicitn√≠ ID krok≈Ø")
        
        # Kontrola z√°vislost√≠ (z√°vislosti mus√≠ b√Ωt na existuj√≠c√≠ kroky)
        for step in self.steps:
            for dep_id in step.dependencies:
                if dep_id not in step_ids:
                    raise ValueError(
                        f"Krok {step.id} m√° z√°vislost na neexistuj√≠c√≠m kroku {dep_id}"
                    )
                # Z√°vislost nesm√≠ b√Ωt na sebe sama
                if dep_id == step.id:
                    raise ValueError(f"Krok {step.id} nem≈Ø≈æe z√°viset s√°m na sobƒõ")
        
        # Kontrola cyklick√Ωch z√°vislost√≠
        self._check_for_cycles()
    
    def _check_for_cycles(self):
        """
        Kontrola cyklick√Ωch z√°vislost√≠ pomoc√≠ DFS.
        
        Raises:
            ValueError: Pokud existuje cyklus
        """
        def has_cycle(step_id: int, visited: set, rec_stack: set) -> bool:
            visited.add(step_id)
            rec_stack.add(step_id)
            
            step = next((s for s in self.steps if s.id == step_id), None)
            if step:
                for dep_id in step.dependencies:
                    if dep_id not in visited:
                        if has_cycle(dep_id, visited, rec_stack):
                            return True
                    elif dep_id in rec_stack:
                        return True
            
            rec_stack.remove(step_id)
            return False
        
        visited = set()
        for step in self.steps:
            if step.id not in visited:
                if has_cycle(step.id, visited, set()):
                    raise ValueError("Pl√°n obsahuje cyklick√© z√°vislosti")
    
    def _display_plan(self):
        """Zobraz√≠ pl√°n v ƒçiteln√©m form√°tu."""
        RichPrinter.info("‚úÖ Pl√°n vytvo≈ôen:")
        total_estimated = sum(s.estimated_tokens for s in self.steps)
        
        for step in self.steps:
            deps_str = ""
            if step.dependencies:
                deps_str = f" [dim](z√°vis√≠ na: {', '.join(map(str, step.dependencies))})[/dim]"
            
            RichPrinter.info(
                f"   [bold]{step.id}.[/bold] {step.description} "
                f"[dim]({step.estimated_tokens} tokens){deps_str}[/dim]"
            )
        
        RichPrinter.info(f"   [dim]Celkem krok≈Ø: {len(self.steps)} | "
                        f"Odhadovan√© tokeny: {total_estimated}[/dim]")
    
    def get_next_step(self) -> Optional[PlanStep]:
        """
        Vr√°t√≠ dal≈°√≠ krok k proveden√≠ (respektuje z√°vislosti).
        
        Returns:
            PlanStep nebo None pokud ≈æ√°dn√Ω dostupn√Ω krok
        """
        for step in self.steps:
            if step.status == "pending":
                # Zkontroluj zda jsou splnƒõny z√°vislosti
                if self._are_dependencies_met(step):
                    return step
        
        return None  # ≈Ω√°dn√Ω dostupn√Ω krok
    
    def _are_dependencies_met(self, step: PlanStep) -> bool:
        """
        Zkontroluje zda jsou splnƒõny v≈°echny z√°vislosti kroku.
        
        Args:
            step: Krok k ovƒõ≈ôen√≠
        
        Returns:
            True pokud v≈°echny z√°vislosti jsou completed
        """
        for dep_id in step.dependencies:
            dep_step = next((s for s in self.steps if s.id == dep_id), None)
            if dep_step and dep_step.status != "completed":
                return False
        return True
    
    def mark_step_in_progress(self, step_id: int):
        """Oznaƒç√≠ krok jako prob√≠haj√≠c√≠."""
        step = self._get_step_by_id(step_id)
        if step:
            step.status = "in_progress"
            RichPrinter.info(f"‚ñ∂Ô∏è  Krok {step_id}: {step.description}")
    
    def mark_step_completed(self, step_id: int, result: str, tokens_used: int):
        """
        Oznaƒç√≠ krok jako dokonƒçen√Ω.
        
        Args:
            step_id: ID kroku
            result: V√Ωsledek proveden√≠ (stdout/odpovƒõƒè)
            tokens_used: Poƒçet spot≈ôebovan√Ωch token≈Ø
        """
        step = self._get_step_by_id(step_id)
        if step:
            step.status = "completed"
            step.result = result
            step.actual_tokens = tokens_used
            RichPrinter.info(
                f"‚úÖ Krok {step_id} dokonƒçen "
                f"[dim]({tokens_used} tokens, "
                f"odhad: {step.estimated_tokens})[/dim]"
            )
    
    def mark_step_failed(self, step_id: int, error: str):
        """
        Oznaƒç√≠ krok jako selhav≈°√≠.
        
        Args:
            step_id: ID kroku
            error: Chybov√° hl√°≈°ka
        """
        step = self._get_step_by_id(step_id)
        if step:
            step.status = "failed"
            step.error = error
            RichPrinter.error(f"‚ùå Krok {step_id} selhal: {error}")
    
    def mark_step_skipped(self, step_id: int, reason: str):
        """
        Oznaƒç√≠ krok jako p≈ôeskoƒçen√Ω.
        
        Args:
            step_id: ID kroku
            reason: D≈Øvod p≈ôeskoƒçen√≠
        """
        step = self._get_step_by_id(step_id)
        if step:
            step.status = "skipped"
            RichPrinter.info(f"‚è≠Ô∏è  Krok {step_id} p≈ôeskoƒçen: {reason}")
    
    def get_progress(self) -> Dict[str, Any]:
        """
        Vr√°t√≠ statistiky pokroku.
        
        Returns:
            {
                "total_steps": int,
                "completed": int,
                "failed": int,
                "in_progress": int,
                "pending": int,
                "progress_percent": float
            }
        """
        total = len(self.steps)
        completed = sum(1 for s in self.steps if s.status == "completed")
        failed = sum(1 for s in self.steps if s.status == "failed")
        in_progress = sum(1 for s in self.steps if s.status == "in_progress")
        pending = sum(1 for s in self.steps if s.status == "pending")
        
        progress_percent = (completed / total * 100) if total > 0 else 0
        
        return {
            "total_steps": total,
            "completed": completed,
            "failed": failed,
            "in_progress": in_progress,
            "pending": pending,
            "skipped": sum(1 for s in self.steps if s.status == "skipped"),
            "progress_percent": progress_percent
        }
    
    def _get_step_by_id(self, step_id: int) -> Optional[PlanStep]:
        """Najde krok podle ID."""
        return next((s for s in self.steps if s.id == step_id), None)
    
    def is_plan_complete(self) -> bool:
        """
        True pokud jsou v≈°echny kroky dokonƒçeny nebo p≈ôeskoƒçeny.
        
        Returns:
            True pokud pl√°n je kompletn√≠ (v≈°echny kroky completed/skipped)
        """
        return all(s.status in ["completed", "skipped"] for s in self.steps)
    
    def has_failures(self) -> bool:
        """True pokud nƒõjak√Ω krok selhal."""
        return any(s.status == "failed" for s in self.steps)
    
    def get_failed_steps(self) -> List[PlanStep]:
        """Vr√°t√≠ seznam selhav≈°√≠ch krok≈Ø."""
        return [s for s in self.steps if s.status == "failed"]
    
    def serialize(self) -> Dict[str, Any]:
        """
        Serializuje pl√°n do JSON-friendly form√°tu.
        
        Returns:
            Dictionary pro ulo≈æen√≠ do state_data
        """
        return {
            "steps": [step.to_dict() for step in self.steps],
            "current_step_index": self.current_step_index,
            "plan_created_at": self.plan_created_at
        }
    
    @classmethod
    def deserialize(cls, data: Dict[str, Any], llm_manager) -> 'PlanManager':
        """
        Obnov√≠ PlanManager ze serializovan√© podoby.
        
        Args:
            data: Serializovan√° data (z serialize())
            llm_manager: Instance LLMManager
        
        Returns:
            Obnoven√Ω PlanManager
        """
        pm = cls(llm_manager)
        pm.steps = [PlanStep.from_dict(s) for s in data["steps"]]
        pm.current_step_index = data.get("current_step_index", 0)
        pm.plan_created_at = data.get("plan_created_at")
        return pm
    
    def __repr__(self) -> str:
        """String reprezentace pro debugging."""
        progress = self.get_progress()
        return (
            f"PlanManager(steps={len(self.steps)}, "
            f"completed={progress['completed']}, "
            f"failed={progress['failed']})"
        )
